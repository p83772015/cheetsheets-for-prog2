* Programming Problems 29-38
:PROPERTIES:
:TOC:      :include all :depth 1
:END:

:CONTENTS:
- [[#programming-problems-29-38][Programming Problems 29-38]]
  - [[#problem29cpp][problem29.cpp]]
  - [[#problem30cpp][problem30.cpp]]
  - [[#problem31cpp][problem31.cpp]]
  - [[#problem32cpp][problem32.cpp]]
  - [[#problem33cpp][problem33.cpp]]
  - [[#problem34cpp][problem34.cpp]]
  - [[#problem35cpp][problem35.cpp]]
  - [[#problem36cpp][problem36.cpp]]
  - [[#problem37cpp][problem37.cpp]]
  - [[#problem38cpp][problem38.cpp]]
:END:


** problem29.cpp
Write a program that reads a file containing floating-point numbers.  Print the average of the numbers in the file.  Prompt the user for the file name.

*** Solution
#+NAME: problem29.cpp
#+begin_src C++ :results output :cmdline <<< 29-floats.txt :exports both
  #include <iostream>
  #include <fstream>
  using namespace std;

  double
  compute_avg_from_file(fstream *file_obj)
  {
    double total = 0;
    size_t count = 0;
    double num;
    while (*file_obj >> num) {
      total += num;
      ++count;
    }
    return total / count;
  }

  int
  main ()
  {
    fstream file_obj;
    string file_name;

    cout << "Welcome to Number Averager Program!\n"
         << "\n"
         << "This program computes the average of numbers in FILE.\n"
         << "Numbers in FILE may be delimited by any whitespace\n"
         << "character.\n"
         << "\n"
         << "Enter FILE: ";
    cin >> file_name;

    // Open the text file.
    file_obj.open(file_name, ios::in);
    if (file_obj.fail()) {
      cerr << "File failed to open.\n";
      exit(1);
    }

    // Compute and print result
    cout << "The average of numbers in '" << file_name
         << "' is: " << compute_avg_from_file(&file_obj)
         << '\n';

    file_obj.close();
    return 0;
  }
#+end_src

*** Sample output
Suppose ~29-floats.txt~ contains:

#+begin_example
3
5.6
23.1 4.7 4.2
#+end_example

The code will output:

#+begin_example
Welcome to Number Averager Program!

This program computes the average of numbers in FILE.
Numbers in FILE may be delimited by any whitespace
character.

Enter FILE: 29-floats.txt
The average of numbers in '29-floats.txt' is: 8.12
#+end_example

*** Resources
- https://stackoverflow.com/a/20372777

** problem30.cpp
Write a program that reads each line in a file, reverses its characters, and writes the resulting line to another file.  Suppose the user specifies ~input.txt~ and ~output.txt~ when prompted for the file names, and ~input.txt~ contains the lines

#+begin_example
Mary had a little lamb
Its fleece was white as snow
And everywhere that Mary went
the lamb was sure to go.
#+end_example

After the program is finished, ~output.txt~ should contain

#+begin_example
bmal elttil a dah yraM
wons sa etihw saw eceelf stI
tnew yraM taht erehwyreve dnA
.og ot erus saw bmal ehT
#+end_example

*** Solution
#+begin_src C++ :results output :cmdline :exports both
  #include <iostream>
  #include <fstream>
  #include <algorithm>
  using namespace std;

  void
  flip_text_file(fstream *file_obj, fstream *flipped_file_obj)
  {
    string line;
    while (getline(*file_obj, line)) {
      reverse(line.begin(), line.end());
      ,*flipped_file_obj << line << '\n';
    }
  }  

  int
  main ()
  {
    fstream file_obj;
    fstream flipped_file_obj;
    string file_name;
    string flipped_file_name;

    cout << "Welcome to Text Flipper Program!\n"
         << "\n"
         << "Horizontally flip a text file.\n"
         << "\n"
         << "Enter input FILE: ";

    // Open the text file for reading.
    cin >> file_name;		// Prompt for text file for reading.
    file_obj.open(file_name, ios::in);
    if (file_obj.fail()) {
      cerr << "File for reading failed to open.\n";
      exit(1);
    }

    // Open the text file for writing.
    cout << "Enter output FILE: ";
    cin >> flipped_file_name;		// Prompt for text file for writing.
    flipped_file_obj.open(flipped_file_name, ios::out);
    if (flipped_file_obj.fail()) {
      cerr << "File for writing failed to open.\n";
      exit(1);
    }

    // Notify user if done!
    flip_text_file(&file_obj, &flipped_file_obj);
    cout << "Flipping done! Please Check the file '"
         << flipped_file_name << "'.\n";

    // Cleanup
    file_obj.close();
    flipped_file_obj.close();
    return 0;
  }
#+end_src

*** Sample output
Suppose ~input.txt~ contains:

#+begin_example
Mary had a little lamb
Its fleece was white as snow
And everywhere that Mary went
the lamb was sure to go.
#+end_example

The code will output:

#+begin_example
Welcome to Text Flipper Program!

Horizontally flip a text file.

Enter input FILE: input.txt
Enter output FILE: output.txt
Flipping done! Please Check the file 'output.txt'.
#+end_example

And ~output.txt~ will contain:

#+begin_src shell
user@host:cpp $ cat reversed-mary-had.txt 
bmal elttil a dah yraM
wons sa etihw saw eceelf stI
tnew yraM taht erehwyreve dnA
.og ot erus saw bmal eht
#+end_src

*** Resources
- https://www.geeksforgeeks.org/read-a-file-line-by-line-in-cpp/?ref=asr5
- https://www.geeksforgeeks.org/how-to-reverse-a-string-in-cpp/

** problem31.cpp
Write a program that will search a file of numbers of type ~int~ and write the largest and the smallest numbers to the screen.  The file contains nothing but numbers separated line breaks.

*** Solution
#+begin_src C++
  #include <iostream>
  #include <fstream>
  using namespace std;

  int *
  find_min_max_in_file(fstream *file_obj)
  {
    int line;
    int *min_max_tuple = (int *)malloc(2 * sizeof(int));
    int highest;
    ,*file_obj >> highest;
    int lowest = highest;
    while (*file_obj >> line) {
      (highest < line) && (highest = line);
      (lowest > line) && (lowest = line);
    }
    min_max_tuple[0] = lowest;
    min_max_tuple[1] = highest;
    return min_max_tuple;
  }

  int
  main ()
  {
    fstream file_obj;
    string file_name;
    int *min_max;

    cout << "Welcome to Min-Max Program!\n"
         << "\n"
         << "Find the smallest and largest integer in FILE.\n"
         << "\n"
         << "Enter FILE: ";
    cin >> file_name;

    // Open the text file.
    file_obj.open(file_name, ios::in);
    if (file_obj.fail()) {
      cerr << "File failed to open.\n";
      exit(1);
    }

    // Compute and print result
    min_max = find_min_max_in_file(&file_obj);
    cout << "Smallest integer: " << min_max[0] << '\n'
         << "Largest integer: " << min_max[1] << '\n';

    // Cleanup
    file_obj.close();
    return 0;
  }
#+end_src

*** Sample Output
Suppose the ~31-numbers.txt~ input file contains:

#+begin_example
190
923
480
248
487
896
265
561
638
11
871
848
172
824
792
40
391
149
311
570
#+end_example

The code will output:

#+begin_example
Welcome to Min-Max Program!

Find the smallest and largest integer in FILE.

Enter FILE: 31-numbers.txt
Smallest integer: 11
Largest integer: 923
#+end_example

*** Resources
- https://www.geeksforgeeks.org/return-an-array-in-c/#return-an-array-in-c-using-pointers

** problem32.cpp
Write a program that merges the numbers in two files and writes all the numbers into a third file.  Your program takes input from two different files and writes its output to a third file.  Each input file contains a list of numbers of type ~int~ in sorted order from the smallest to the largest.  After the program is run, the output file will contain all the numbers in the two input files in one longer list in sorted order from smallest to largest.  Your program should define a function that will sort the values of the two input files.

*** Solution
#+begin_src C++
  #include <iostream>
  #include <fstream>
  using namespace std;

  // Implement linked lists (for fun!)
  struct int_linked_list
  {
    int num;
    struct int_linked_list *next;
  };

  struct int_linked_list *
  initialize_int_linked_list(int num)
  {
    struct int_linked_list *p;
    p = (struct int_linked_list *)malloc(sizeof(struct int_linked_list));

    if (p == NULL)
      throw new runtime_error("Ran out of storage.");

    p->num = num;
    p->next = NULL;

    return p;
  }

  struct int_linked_list *
  add_to_int_linked_list(struct int_linked_list *list_item_ptr, int num)
  {
    struct int_linked_list *new_item = initialize_int_linked_list(num);
    if (list_item_ptr) new_item->next = list_item_ptr;
    return new_item;
  }

  void
  print_int_linked_list(struct int_linked_list *list_item_ptr)
  {
    while (list_item_ptr) {
      cout << list_item_ptr->num << " ";
      list_item_ptr = list_item_ptr->next;
    }
  }

  size_t
  sizeof_int_linked_list(struct int_linked_list *list_item_ptr)
  {
    size_t count = 0;
    while (list_item_ptr) {
      ++count;
      list_item_ptr = list_item_ptr->next;
    }
    return count;
  }

  void
  free_int_linked_list(struct int_linked_list *list_item_ptr)
  {
    while (list_item_ptr) {
      struct int_linked_list *next_item = list_item_ptr;
      list_item_ptr = list_item_ptr->next;
      free(next_item);
    }
  }

  int *
  int_linked_list_to_array(struct int_linked_list *list_item_ptr, size_t *arrsize)
  {
    size_t i = 0;
    ,*arrsize = sizeof_int_linked_list(list_item_ptr);
    int *arr = (int *)malloc(*arrsize * sizeof(int));
    while (list_item_ptr) {
      arr[i] = list_item_ptr->num;
      ++i;
      list_item_ptr = list_item_ptr->next;
    }
    return arr;
  }

  struct int_linked_list *
  append_int_linked_list(struct int_linked_list *list_item_ptr1,
  		       struct int_linked_list *list_item_ptr2)
  {
    if (!list_item_ptr1 || !list_item_ptr2) {
      throw runtime_error("Passed null pointer.");
    }
    struct int_linked_list *first_elt_ptr = list_item_ptr1;
    while (list_item_ptr1->next) {
      list_item_ptr1 = list_item_ptr1->next;
    }
    list_item_ptr1->next = list_item_ptr2;
    return first_elt_ptr;
  }

  void
  swap(int *a, int*b)
  {
    int temp = *a;
    ,*a = *b;
    ,*b = temp;
  }

  void
  bubble_sort(int *arr, size_t n)
  {
    for (size_t i = 0; i < n - 1; ++i) {
      for (size_t j = 0; j < n - i - 1; ++j) {
        if (arr[j] > arr[j+1]) {
  	swap(arr+j, arr+j+1);
        }
      }
    }
  }

  void
  merge_sort_and_dump_files_of_ints(fstream *file1_obj,
  				  fstream *file2_obj,
  				  fstream *file3_obj)
  {
    struct int_linked_list *file1_values = NULL;
    struct int_linked_list *file2_values = NULL;
    struct int_linked_list *file3_values = NULL;
    size_t file3_arrsize;
    int num;

    while (*file1_obj >> num)
      file1_values = add_to_int_linked_list(file1_values, num);
    while (*file2_obj >> num)
      file2_values = add_to_int_linked_list(file2_values, num);

    file3_values = append_int_linked_list(file1_values, file2_values);
    int *file3_array = int_linked_list_to_array(file3_values, &file3_arrsize);
    bubble_sort(file3_array, file3_arrsize);

    for (size_t i = 0; i < file3_arrsize; ++i) {
      ,*file3_obj << file3_array[i] << '\n';
    }

    free_int_linked_list(file3_values);
  }

  int
  main ()
  {
    fstream file_obj_1;
    fstream file_obj_2;
    fstream file_obj_3;
    string file_name_1;
    string file_name_2;
    string file_name_3;

    cout << "Welcome to Files of Integers Merger Program!\n"
         << "\n"
         << "Merge sorted numbers from FILE1 and FILE2.\n"
         << "Output is dumped on FILE3 in ascending order."
         << "\n\n";

    // Open the text file 1 for reading.
    cout << "Enter file name of FILE1: ";
    cin >> file_name_1;		// Prompt for text file for reading.
    file_obj_1.open(file_name_1, ios::in);
    if (file_obj_1.fail()) {
      cerr << "'" << file_name_1 << "' for reading failed to open.\n";
      exit(1);
    }

    // Open the text file 2 for reading.
    cout << "Enter file name of FILE2: ";
    cin >> file_name_2;		// Prompt for text file for reading.
    file_obj_2.open(file_name_2, ios::in);
    if (file_obj_2.fail()) {
      cerr << "'" << file_name_2 << "' for reading failed to open.\n";
      exit(2);
    }

    // Open the text file 3 for writing.
    cout << "Enter file name of FILE3: ";
    cin >> file_name_3;		// Prompt for text file for reading.
    file_obj_3.open(file_name_3, ios::out);
    if (file_obj_3.fail()) {
      cerr << "'" << file_name_3 << "' for writing failed to open.\n";
      exit(3);
    }

    // Notify user if done!
    merge_sort_and_dump_files_of_ints(&file_obj_1, &file_obj_2, &file_obj_3);
    cout << "\nDone! Please Check the file '"
         << file_name_3 << "'.\n";

    // Cleanup
    file_obj_1.close();
    file_obj_2.close();
    file_obj_3.close();
    
    return 0;
  }
#+end_src

*** Sample Output

#+begin_example
Welcome to Files of Integers Merger Program!

Merge sorted numbers from FILE1 and FILE2.
Output is dumped on FILE3 in ascending order.

Enter file name of FILE1: problem-32-numbers-1.txt
Enter file name of FILE2: problem-32-numbers-2.txt
Enter file name of FILE3: problem-32-output.txt

Done! Please Check the file 'problem-32-output.txt'.
#+end_example

Suppose ~problem-32-numbers-1.txt~ contains:

#+begin_example
29
50
63
25
77
#+end_example

And ~problem-32-numbers-2.txt~ contains:

#+begin_example
22
21
34
75
89
#+end_example

The code will create a file named ~problem-32-output.txt~ containing these values:

#+begin_example
21
22
25
29
34
50
63
75
77
89
#+end_example

*** Resources
- https://www.geeksforgeeks.org/bubble-sort-algorithm/
- https://www.geeksforgeeks.org/c-bubble-sort/
- https://www.geeksforgeeks.org/return-an-array-in-c/#return-an-array-in-c-using-pointers
- https://stackoverflow.com/questions/36433798/c-malloc-invalid-conversion-from-void-to-struct
- https://www.geeksforgeeks.org/structures-c/

** problem33.cpp
Write a program to compute numeric grades for a course.  The course records are in a file that will serve as the input file.  The input file is in the following format: Each line contains a student’s last name, then one space, then the student’s first name, then one space, then ten quiz scores all on one line.  The quiz scores are whole numbers and are separated by one space.  Make a list of 10 students in the input file.  Your program will take its input from this file and send its output to a second file.  The data in the output file will be the same as the data in the input file except that there will be one additional number (of type double ) at the end of each line.  This number will be the average of the student’s ten quiz scores.  Write a function that computes the average of each individual student.

*** Solution
#+begin_src C++
  #include <iostream>
  #include <fstream>
  using namespace std;

  // A `quiz' item data structure.
  struct quiz
  {
    string last_name;
    string first_name;
    int grades[10];
    double avg;
  };

  // Function to initialize a `quiz' data structure.
  struct quiz *
  init_quiz(string last_name, string first_name, int grades[])
  {
    struct quiz *qs;
    int total = 0;
    qs = (struct quiz *)malloc(sizeof(struct quiz));

    if (qs == NULL)
      throw new runtime_error("Ran out of storage.");

    qs->last_name = last_name;
    qs->first_name = first_name;
    for (size_t i = 0; i < 10; ++i) {
      total += grades[i];
      qs->grades[i] = grades[i];
    }
    qs->avg = total / 10.0;

    return qs;
  }

  void
  export_avg(fstream *input_file_obj, fstream *output_file_obj)
  {
    // Temporary storage.
    string cell;
    string last_name;
    string first_name;
    int grades[10];
    struct quiz *quizzes[10];

    // For each empty array element, build the quiz structure and assign
    // it to a position of the quizzes array.
    for (size_t i = 0; i < 10; ++i) {
      ,*input_file_obj >> last_name;
      ,*input_file_obj >> first_name;
      for (size_t j = 0; j < 10; ++j) {
        ,*input_file_obj >> grades[j];
      }
      quizzes[i] = init_quiz(last_name, first_name, grades); // Bulid struct.
    }

    // For each quiz item, write it to the file object for output.
    for (size_t i = 0; i < 10; ++i) {
      ,*output_file_obj << quizzes[i]->last_name << ' ';
      ,*output_file_obj << quizzes[i]->first_name << ' ';
      // Iterate through the grades array field of the current quiz
      // struct.
      for (size_t j = 0; j < 10; ++j) {
        ,*output_file_obj << quizzes[i]->grades[j] << ' ';
      }
      ,*output_file_obj << quizzes[i]->avg << '\n';
    }

    // Memory safety!
    for (size_t i = 0; i < 10; ++i) {
      free(quizzes[i]);
    }

  }

  int
  main ()
  {
      fstream input_file_obj;
      fstream output_file_obj;
      string input_file_name;
      string output_file_name;

      cout << "Welcome to Quiz Averager Program!\n"
  	 << "\n"
  	 << "Compute the average of the students' quizzes in FILE.\n"
  	 << "FILE should be a text file containing the records of students'\n"
  	 << "quizzes. Records are separated by a newline; columns are\n"
  	 << "separated by one or more white space characters.\n"
  	 << "\n\n";

      // Open the text file for reading.
      cout << "Enter input FILE: ";
      cin >> input_file_name;		// Prompt for text file for reading.
      input_file_obj.open(input_file_name, ios::in);
      if (input_file_obj.fail()) {
        cerr << "File for reading failed to open.\n";
        exit(1);
      }

      // Open the text file for writing.
      output_file_name =
        input_file_name.substr(0, input_file_name.find_last_of("."))
        + "-with-avg.txt";
      output_file_obj.open(output_file_name, ios::out);
      if (output_file_obj.fail()) {
        cerr << "File for writing failed to open.\n";
        exit(1);
      }

      // Notify user if done!
      export_avg(&input_file_obj, &output_file_obj);
      cout << "Averaging done! Please Check the file '"
  	 << output_file_name << "'.\n";

      // Cleanup
      input_file_obj.close();
      output_file_obj.close();

    return 0;
  }
#+end_src

*** Sample output
Terminal output:

#+begin_example
Welcome to Quiz Averager Program!

Compute the average of the students' quizzes in FILE.
FILE should be a text file containing the records of students'
quizzes. Records are separated by a newline; columns are
separated by one or more white space characters.


Enter input FILE: quizzes.txt
Averaging done! Please Check the file 'quizzes-with-avg.txt'.
#+end_example

Contents of ~quizzes.txt~:

#+begin_example
Rey Edgar 94 81 92 93 98 97 94 92 96 80
Caneta Angelo 96 98 88 97 99 92 90 89 83 83
Florendo Aizle 86 87 88 93 90 98 96 95 87 84
Leona Christian 81 88 89 93 88 91 96 96 86 82
Aureus Karl 98 99 83 88 91 97 95 88 89 96
Orbita Chistian 92 80 81 89 91 93 86 95 80 83
Rey Emil 91 98 80 89 93 90 85 81 88 85
Camasis Ace 89 84 85 97 86 82 89 96 84 99
Rabosa Adian 89 99 88 99 94 98 82 89 88 95
Zape Ben 96 96 81 81 99 99 99 90 86 93
#+end_example

Contents of ~quizzes-with-avg.txt~:

#+begin_example
Rey Edgar 94 81 92 93 98 97 94 92 96 80 91.7
Caneta Angelo 96 98 88 97 99 92 90 89 83 83 91.5
Florendo Aizle 86 87 88 93 90 98 96 95 87 84 90.4
Leona Christian 81 88 89 93 88 91 96 96 86 82 89
Aureus Karl 98 99 83 88 91 97 95 88 89 96 92.4
Orbita Chistian 92 80 81 89 91 93 86 95 80 83 87
Rey Emil 91 98 80 89 93 90 85 81 88 85 88
Camasis Ace 89 84 85 97 86 82 89 96 84 99 89.1
Rabosa Adian 89 99 88 99 94 98 82 89 88 95 92.1
Zape Ben 96 96 81 81 99 99 99 90 86 93 92
#+end_example

*** Resources
- https://stackoverflow.com/questions/6417817/easy-way-to-remove-extension-from-a-filename
- https://stackoverflow.com/questions/56524609/warning-iso-c-forbids-converting-a-string-constant-to-char-wwrite-string

** problem34.cpp
Create a program to read a file (~data.txt~) with a set of numbers then the program will determine the odd numbers and even numbers in the file.  Print the odd numbers in the file called ~odd.txt~ and even numbers in the file called ~even.txt~.

*** Solution
#+begin_src C++
  #include <iostream>
  #include <fstream>
  using namespace std;

  void
  export_odd_even(fstream *input_file_obj)
  {
    fstream even_file_obj;
    fstream odd_file_obj;
    int num;

    while (*input_file_obj >> num) {
      if (num % 2 == 0) {
        // This branch runs if `num` is even.
        if (!even_file_obj.is_open()) {
  	// Open `even.txt` only if `num % 2 == 0`.
  	even_file_obj.open("even.txt", ios::out);
  	if (even_file_obj.fail()) {
  	  cerr << "File for writing failed to open.\n";
  	  exit(1);
  	}
        }
        even_file_obj << num << '\n';
      } else {
        // This branch runs if `num` is odd.
        if (!odd_file_obj.is_open()) {
  	// Open `odd.txt` only if `num % 2 != 0`.
  	odd_file_obj.open("odd.txt", ios::out);
  	if (odd_file_obj.fail()) {
  	  cerr << "File for writing failed to open.\n";
  	  exit(1);
  	}
        }
        odd_file_obj << num << '\n';
      }
    }

    even_file_obj.close();
    odd_file_obj.close();
  }

  int
  main ()
  {
    fstream input_file_obj;
    string input_file_name;

    cout << "Welcome to Odd and Even Finder Program!\n"
         << "\n"
         << "Find in FILE all the odd and even numbers.\n"
         << "Results are put to odd.txt and even.txt.\n"
         << "\n"
         << "Enter input FILE: ";

    // Open the text file for reading.
    cin >> input_file_name;		// Prompt for text file for reading.
    input_file_obj.open(input_file_name, ios::in);
    if (input_file_obj.fail()) {
      cerr << "File for reading failed to open.\n";
      exit(1);
    }

    // Notify user if done!
    export_odd_even(&input_file_obj);
    cout << "Finding done! Please Check the files 'odd.txt' and 'even.txt'."
         << '\n';

    // Cleanup
    input_file_obj.close();
    return 0;
  }
#+end_src

*** Sample output
#+begin_example
Welcome to Odd and Even Finder Program!

Find in FILE all the odd and even numbers.
Results are put to odd.txt and even.txt.

Enter input FILE: 34-numbers.txt
Finding done! Please Check the files 'odd.txt' and 'even.txt'.
#+end_example

With ~34-numbers.txt~ containing:

#+begin_example
34 35 89
20
44 64
73 6 7 61 13 64
65
19
91 61
51
4
21
0 
#+end_example

Running the program will create ~odd.txt~ containing:

#+begin_example
35
89
73
7
61
13
65
19
91
61
51
21
#+end_example

and ~even.txt~ containing:

#+begin_example
34
20
44
64
6
64
4
0
#+end_example

** problem35.cpp
Boardman College maintains two files—one for Sociology majors and another for Anthropology majors.  Each file contains students’ ID numbers, last names, first names, and grade point averages.  Each file is in student ID number order.

The college is merging the two departments into a Department of Sociology and Anthropology.  Design the logic for a program that merges the two files into one file containing a list of all students, maintaining ID number order.

#+begin_src C++
  #include <iostream>
  #include <fstream>
  #include <iomanip>
  using namespace std;

  struct student_struct
  {
    int student_id;
    string last_name;
    string first_name;
    double gpa;
  };

  struct student_struct *
  construct_student(int student_id, string last_name, string first_name, double gpa)
  {
    struct student_struct *student;
    student = (struct student_struct *)malloc(sizeof(struct student_struct));
    if (student == NULL) {
      throw new runtime_error("Ran out of storage.");
    }

    student->student_id = student_id;
    student->last_name = last_name;
    student->first_name = first_name;
    student->gpa = gpa;

    return student;
  }

  void
  clean_array_of_students(struct student_struct *students[], size_t size)
  {
    for (size_t i = 0; i < size; ++i) {
      free(students[i]);
    }
  }

  size_t
  count_lines(fstream *file)
  {
    string line;
    size_t count = 0;
    while(getline(*file, line)) {
      ++count;
    }
    file->clear();
    file->seekg(0);			// Position cursor back into
  					// beginning of file.
    return count;
  }

  void swap_students(struct student_struct *a,
  		   struct student_struct *b)
  {
    student_struct temp = *a;
    ,*a = *b;
    ,*b = temp;
  }

  void
  bubble_sort_students(struct student_struct **arr, size_t n)
  {
    for (size_t i = 0; i < n - 1; ++i) {
      for (size_t j = 0; j < n - i - 1; ++j) {
        if (arr[j]->student_id > arr[j+1]->student_id) {
  	swap_students(*arr+j, *arr+j+1);
        }
      }
    }
  }

  void
  merge_and_export(fstream *file1, fstream *file2, fstream *file_out)
  {
    int student_id;
    string last_name;
    string first_name;
    double gpa;
    string file_name;
    size_t file1_line_count = count_lines(file1);
    size_t file2_line_count = count_lines(file2);
    size_t total_records = file1_line_count + file2_line_count;
    size_t i = 0;

    // Declare an array of `students'.
    struct student_struct *students[total_records];

    // For each line of the 1st file, fill out the fields of each
    // `student' in the `students' array.
    while (i < file1_line_count) {
      ,*file1 >> student_id;
      ,*file1 >> last_name;
      ,*file1 >> first_name;
      ,*file1 >> gpa;
      students[i++] = construct_student(student_id, last_name, first_name, gpa);
    }

    // For each line of the 2st file, fill out the fields of each
    // `student' in the `students' array.
    while (i < total_records) {
      ,*file2 >> student_id;
      ,*file2 >> last_name;
      ,*file2 >> first_name;
      ,*file2 >> gpa;
      students[i++] = construct_student(student_id, last_name, first_name, gpa);
    }
    
    // Sort the array of students by their `student_id'
    bubble_sort_students(students, total_records);


    // Place each item in the merged `students' array in the output
    // file.
    for (size_t i = 0; i < total_records; ++i) {
      ,*file_out << left << setw(8) << students[i]->student_id
  	      << setw(12) << students[i]->last_name
  	      << setw(12) << students[i]->first_name
  	      << students[i]->gpa
  	      << '\n';
    }

    // cout << "I'm here! i = " << i << '\n';
    // exit(0);

    // Cleanup: Avoid leaking memory.
    clean_array_of_students(students, total_records);
  }    
      

  int
  main ()
  {
    fstream input_file_obj;
    string input_file_name;
    fstream input2_file_obj;
    string input2_file_name;
    fstream output_file_obj;
    string output_file_name;

     cout << "Welcome to Student Database Merger Program!\n"
  	<< "\n"
  	<< "Merge student databases. You may provide one or more\n"
  	<< "files separated by whitespace. Enter 'q' to finilize files.\n"
  	<< "\n";

    // Open the text file for reading.
    cout << "Enter FILE 1: ";
    cin >> input_file_name;		// Prompt for text file for reading.
    input_file_obj.open(input_file_name, ios::in);
    if (input_file_obj.fail()) {
      cerr << "File for reading failed to open.\n";
      exit(1);
    }

    // Open the text file for reading.
    cout << "Enter FILE 2: ";
    cin >> input2_file_name;		// Prompt for text file for reading.
    input2_file_obj.open(input2_file_name, ios::in);
    if (input2_file_obj.fail()) {
      cerr << "File for reading failed to open.\n";
      exit(1);
    }

    // Open the text file for writing.
    cout << "Enter output FILE name: ";
    cin >> output_file_name;		// Prompt for text file for writing.
    output_file_obj.open(output_file_name, ios::out);
    if (output_file_obj.fail()) {
      cerr << "File for writing failed to open.\n";
      exit(1);
    }

    // Notify user if done!
    merge_and_export(&input_file_obj, &input2_file_obj, &output_file_obj);
    cout << "\nMerging done! Please Check the file '"
         << output_file_name << "'.\n";


    // Cleanup
    input_file_obj.close();
    input2_file_obj.close();
    output_file_obj.close();
  }
#+end_src

*** Sample Output
#+begin_example
Welcome to Student Database Merger Program!

Merge student databases. You may provide one or more
files separated by whitespace. Enter 'q' to finilize files.

Enter FILE 1: 35-sociology-students.txt
Enter FILE 2: 35-anthropology-students.txt
Enter output FILE name: 35-merged-students.txt

Merging done! Please Check the file '35-merged-students.txt'.
#+end_example

If ~35-sociology-students.txt~ contains:

#+begin_example
1001    Smith      John       3.5
1002    Johnson    Emily      3.8
1003    Williams   Michael    3.2
1004    Brown      Sarah      3.9
1005    Jones      David      3.0
1006    Garcia     Jessica    3.7
1007    Martinez   Daniel     3.4
1008    Davis      Laura      3.6
1009    Rodriguez  James      3.1
1010    Wilson     Emma       3.3
#+end_example

and ~35-anthropology-students.txt~ contains:

#+begin_example
2001    Taylor     Olivia     3.7
2002    Anderson   Ethan      3.4
2003    Thomas     Ava        3.6
2004    Jackson    Noah       3.8
2005    White      Mia        3.5
2006    Harris     Lucas      3.2
2007    Martin     Sophia     3.9
2008    Thompson   Benjamin   3.1
2009    Garcia     Charlotte  3.3
2010    Martinez   Alexander  3.0
#+end_example

the resulting file ~35-merged-students.txt~ will conatain:

#+begin_example
1001    Smith       John        3.5
1002    Johnson     Emily       3.8
1003    Williams    Michael     3.2
1004    Brown       Sarah       3.9
1005    Jones       David       3
1006    Garcia      Jessica     3.7
1007    Martinez    Daniel      3.4
1008    Davis       Laura       3.6
1009    Rodriguez   James       3.1
1010    Wilson      Emma        3.3
2001    Taylor      Olivia      3.7
2002    Anderson    Ethan       3.4
2003    Thomas      Ava         3.6
2004    Jackson     Noah        3.8
2005    White       Mia         3.5
2006    Harris      Lucas       3.2
2007    Martin      Sophia      3.9
2008    Thompson    Benjamin    3.1
2009    Garcia      Charlotte   3.3
2010    Martinez    Alexander   3
#+end_example

*** References
- https://stackoverflow.com/questions/7681555/resetting-the-end-of-file-state-of-a-ifstream-object-in-c
- 

** problem36.cpp
The Apgar Medical group keeps a patient file for each doctor in the office.  Each record contains the patient’s first and last name, home address, and birth year.  The records are sorted in ascending birth year order.  Two doctors, Dr.  Best and Dr.  Cushing, have formed a partnership.

Create a program that produces a file of merged list of patients’ names in ascending order by birth year.

Create another file that it does not display patients’ names, but only produces a count of the number of patients born each year.

*** Solution
#+begin_src C++
  #include <iostream>
  #include <fstream>
  #include <sstream>
  using namespace std;

  struct Patient
  {
    string first_name;
    string last_name;
    string address;
    int birth_year;
  };

  /*********/
  /* Utils */
  /*********/

  void
  safe_open(fstream *file, string name, ios_base::openmode flag)
  {
    file->open(name, flag);
    if (file->fail()) {
      cerr << name << " for reading failed to open.\n";
      exit(1);
    }
  }

  void swap_patients(struct Patient *a,
  		   struct Patient *b)
  {
    Patient temp = *a;
    ,*a = *b;
    ,*b = temp;
  }

  void
  bubble_sort_patients(struct Patient *arr, size_t n)
  {
    for (size_t i = 0; i < n - 1; ++i) {
      for (size_t j = 0; j < n - i - 1; ++j) {
        if (arr[j].birth_year > arr[j+1].birth_year) {
  	swap_patients(arr+j, arr+j+1);
        }
      }
    }
  }

  /*************/
  /* End Utils */
  /*************/

  void
  add_patients(struct Patient patients[],
  	     fstream *file,
  	     size_t *size)
  {
    string first_name;
    string last_name;
    string address;
    string birth_year_s;
    string line;
    stringstream ss;
    patients = patients + *size;

    while (getline(*file, line)) {
      ss.clear();
      ss << line;
      getline(ss, patients->first_name, '|');
      getline(ss, patients->last_name, '|');
      getline(ss, patients->address, '|');
      getline(ss, birth_year_s);
      patients->birth_year = stoi(birth_year_s);
      (*size)++;
      patients++;
    }
  }

  void
  write_patients_to_file(struct Patient patients[],
  		       size_t size,
  		       fstream *output_file)
  {
    for (; size > 0; size--) {
      ,*output_file << patients->first_name << '|'
  		 << patients->last_name << '|'
  		 << patients->address << '|'
  		 << patients->birth_year << '|'
  		 << '\n';
      patients++;
    }
  }

  void
  merge_patient_db(struct Patient patients[],
  		 size_t *patients_size,
  		 fstream *patient_file_obj_1,
  		 fstream *patient_file_obj_2,
  		 fstream *merged_db_obj)
  {
    string cell;
    string first_name, last_name, address;
    string birth_year;

    add_patients(patients, patient_file_obj_1, patients_size);
    add_patients(patients, patient_file_obj_2, patients_size);

    bubble_sort_patients(patients, *patients_size);
    write_patients_to_file(patients, *patients_size, merged_db_obj);
  }

  struct Freq
  {
    int birth_year;
    size_t count;
  };

  void
  add_to_freq(struct Freq freq[], size_t *patients_size, int value)
  {
    for (size_t i = 0; i < *patients_size; ++i) {
      if (freq[i].birth_year == value) {
        (freq[i].count)++;
        return;
      }
    }
    freq[*patients_size].birth_year = value;
    freq[*patients_size].count = 1;
    (*patients_size)++;
  }

  void
  generate_frequency_dist(struct Patient patients[],
  			size_t patients_size,
  			fstream *output_file)
  {
    struct Freq birth_year_freq[50];
    size_t birth_year_freq_size = 0;
    
    for (; patients_size > 0; --patients_size) {
      add_to_freq(birth_year_freq,
  		&birth_year_freq_size,
  		patients->birth_year);
      patients++;
    }

    for (size_t i = 0; i < birth_year_freq_size; ++i) {
      ,*output_file << birth_year_freq[i].birth_year << '|'
  		 << birth_year_freq[i].count << '\n';
    }
  }

  int
  main ()
  {
    fstream patient_db_1_obj;
    string patient_db_1_name;
    fstream patient_db_2_obj;
    string patient_db_2_name;
    fstream merged_db_obj;
    fstream frequency_file_obj;

    struct Patient patients[255];
    size_t patients_size = 0;

    cout << "Welcome to Patient Database Merger Program!\n"
         << "\n"
         << "Merge two databases of patient records and sort\n"
         << "them by their birth year. Additionally, produce a\n"
         << "file containing the frequency of merged database's\n"
         << "birth year.\n"
         << "\n";
    
    // Open the text file for reading.
    cout << "Enter first Patient db file name: ";
    cin >> patient_db_1_name;		// Prompt for text file for reading.
    safe_open(&patient_db_1_obj, patient_db_1_name, ios::in);

    // Open the text file for reading.
    cout << "Enter second Patient db file name: ";
    cin >> patient_db_2_name;		// Prompt for text file for reading.
    safe_open(&patient_db_2_obj, patient_db_2_name, ios::in);

    safe_open(&merged_db_obj, "merged-patients-db.txt", (ios::out | ios::in));
    safe_open(&frequency_file_obj, "frequency.txt", ios::out);

    // Notify user if done!
    merge_patient_db(patients,
  		   &patients_size,
  		   &patient_db_1_obj,
  		   &patient_db_2_obj,
  		   &merged_db_obj);
    generate_frequency_dist(patients,
  			  patients_size,
  			  &frequency_file_obj);
    cout << "\nMerging done!\n"
         << "Please Check the file(s): "
         << "'merged-patients-db.txt' and 'frequency.txt'\n";

    // Cleanup
    patient_db_1_obj.close();
    patient_db_2_obj.close();
    merged_db_obj.close();
    frequency_file_obj.close();

    return 0;
  }
#+end_src

*** Sample output
#+begin_example
Welcome to Patient Database Merger Program!

Merge two databases of patient records and sort
them by their birth year. Additionally, produce a
file containing the frequency of merged database's
birth year.

Enter first Patient db file name: 36-cushing-patients.txt
Enter second Patient db file name: 36-best-patients.txt

Merging done!
Please Check the file(s): 'merged-patients-db.txt' and 'frequency.txt'
#+end_example

Files Generated:

#+CAPTION: merged-patients-db.txt
#+begin_example
James|Martinez|468 Spruce St, Riverdale, NY|1980|
Jane|Smith|456 Elm St, Metropolis, NY|1980|
Michael|Brown|321 Pine St, Star City, CA|1980|
Emily|Johnson|789 Oak St, Gotham, NJ|1982|
John|Doe|123 Main St, Springfield, IL|1985|
Olivia|Rodriguez|579 Walnut Dr, Starling City, WA|1986|
David|Jones|246 Birch Rd, Smallville, KS|1988|
Alice|Williams|135 Cherry Ln, Hill Valley, CA|1992|
Sarah|Davis|654 Maple St, Central City, TX|1992|
Sophia|Garcia|357 Cedar Ave, Sunnydale, FL|1994|
#+end_example

#+CAPTION: frequency.txt
#+begin_example
1980|3
1982|1
1985|1
1986|1
1988|1
1992|2
1994|1
#+end_example

*** Resources
- https://stackoverflow.com/questions/28338775/what-is-iosiniosout
- https://cplusplus.com/doc/tutorial/files/
- https://www.w3schools.com/cpp/ref_fstream_fstream.asp
- https://www.geeksforgeeks.org/stringstream-c-applications/
- https://stackoverflow.com/questions/37957080/can-i-use-2-or-more-delimiters-in-c-function-getline
- https://stackoverflow.com/questions/4442658/c-parse-int-from-string

** problem37.cpp
The MartinWeight Loss Clinic maintains a patient file, each record contains the name of a patient, its gender and current total weight loss in pounds.

Create a function that separates the client file to produce two files — one for male clients and one for female clients.

Each file is in descending weight loss order.

** Solution
#+begin_src C++
  #include <iostream>
  #include <fstream>
  #include <sstream>
  using namespace std;

  struct Patient
  {
    string name;
    string gender;
    int lbs;
  };

  /*********/
  /* Utils */
  /*********/

  void
  safe_open(fstream *file, string name, ios_base::openmode flag)
  {
    file->open(name, flag);
    if (file->fail()) {
      cerr << name << " for reading failed to open.\n";
      exit(1);
    }
  }

  void swap_patients(struct Patient *a,
  		   struct Patient *b)
  {
    Patient temp = *a;
    ,*a = *b;
    ,*b = temp;
  }

  void
  bubble_sort_patients(struct Patient arr[], size_t n)
  {
    for (size_t i = 0; i < n - 1; ++i) {
      for (size_t j = 0; j < n - i - 1; ++j) {
        if (arr[j].lbs < arr[j+1].lbs) {
  	swap_patients(arr+j, arr+j+1);
        }
      }
    }
  }

  /*************/
  /* End Utils */
  /*************/

  void
  add_patients(struct Patient patients[],
  	     fstream *from_file,
  	     size_t *size)
  {
    string line;
    string lbs_s;
    stringstream ss;
    while(getline(*from_file, line)) {
      ss.clear();
      ss << line;
      getline(ss, patients->name, '|');
      getline(ss, patients->gender, '|');
      getline(ss, lbs_s, '|');
      patients->lbs = stoi(lbs_s);
      patients++;
      (*size)++;
    }
  }
  	     

  void
  split_patient_file(struct Patient patients[],
  		   size_t *patients_size,
  		   fstream *input_file,
  		   fstream *male_output_file,
  		   fstream *female_output_file)
  {
    add_patients(patients, input_file, patients_size);
    bubble_sort_patients(patients, *patients_size);

    for (size_t i = 0; i < *patients_size; ++i) {
      if (patients[i].gender == "Female") {
        ,*female_output_file << patients[i].name << '|'
  			  << patients[i].gender << '|'
  			  << patients[i].lbs << '\n';
      } else if ((patients[i].gender == "Male")) {
        ,*male_output_file << patients[i].name << '|'
  			  << patients[i].gender << '|'
  			  << patients[i].lbs << '\n';
      }
    }
  }

  int
  main ()
  {
    fstream input_file_1_obj;
    string input_file_1_name;
    fstream male_output_obj;
    fstream female_output_obj;

    struct Patient patients[255];
    size_t patients_size = 0;

    cout << "Welcome to Patient File Separator Program!\n"
         << "\n"
         << "Split PATIENT FILE by gender; sort it by weight loss in descending order.\n"
         << "\n";
    
    // Open the text file for reading.
    cout << "Enter PATIENT FILE [1]: ";
    cin >> input_file_1_name;		// Prompt for text file for reading.
    safe_open(&input_file_1_obj, input_file_1_name, ios::in);

    safe_open(&male_output_obj, "37-male.txt", ios::out);
    safe_open(&female_output_obj, "37-female.txt", ios::out);

    // Notify user if done!
    split_patient_file(patients,
  		     &patients_size,
  		     &input_file_1_obj,
  		     &male_output_obj,
  		     &female_output_obj);
    cout << "\nSplitting done!\n"
         << "Please Check the file(s): "
         << "'37-male.txt' and '37-female.txt\n";

    // Cleanup
    input_file_1_obj.close();
    male_output_obj.close();
    female_output_obj.close();

    return 0;
  }
#+end_src

** Sample output
#+begin_example
Welcome to Patient File Separator Program!

Split PATIENT FILE by gender; sort it by weight loss in descending order.

Enter PATIENT FILE [1]: 37-patient-file.txt

Splitting done!
Please Check the file(s): '37-male.txt' and '37-female.txt
#+end_example

Files Generated:

#+CAPTION: female.txt
#+begin_example
Emma Wilson|Female|30
Ivy Thompson|Female|22
Grace Davis|Female|18
Alice Johnson|Female|15
Carol Lee|Female|10
#+end_example

#+CAPTION: male.txt
#+begin_example
David Brown|Male|25
Bob Smith|Male|20
Henry Clark|Male|12
Jack White|Male|8
Frank Miller|Male|5
#+end_example

** problem38.cpp
Create a file containing the following names, Social Security numbers, hourly rate, and hours worked.

| Eddie Vedder  | 555-98-4182 | 7.32 | 37 |
| Scott Weiland | 555-53-2147 | 8.32 | 40 |
| Axl Rose      | 555-32-9826 | 6.54 | 40 |
| Phil Anselmo  | 555-09-4263 | 9.80 | 35 |

Write a C++ program that reads the data file and computes and displays a payroll schedule.  The output should list the Name, Social Security Number and Gross pay for every individual.
